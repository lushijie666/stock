# 美股30分钟数据 - 开盘价修复方案

## 问题描述

在使用 akshare 的 `stock_us_hist_min_em` 接口获取1分钟数据并聚合为30分钟数据时，发现部分聚合后的K线开盘价为0。

### 问题原因

1. **数据源问题**: akshare 的 `stock_us_hist_min_em` 接口返回的1分钟数据中，很多记录的开盘价字段为0
2. **聚合逻辑**: 使用 pandas 的 `resample('30min').agg({'开盘': 'first'})` 聚合时，如果某个30分钟时段的第一条1分钟数据的开盘价为0，聚合后的30分钟K线开盘价也会变成0

### 示例

```
原始1分钟数据:
时间                  开盘    收盘
2025-12-22 22:30:00  100.0  100.5  ← 第1个30分钟时段的第1条
2025-12-22 22:31:00  100.5  101.0
...
2025-12-22 22:59:00  114.5  115.0
2025-12-22 23:00:00    0.0  115.5  ← 第2个30分钟时段的第1条，开盘为0！
2025-12-22 23:01:00  115.5  116.0
...

聚合后（未修复前）:
时间                  开盘    收盘
2025-12-22 22:30:00  100.0  115.0  ✓ 正常
2025-12-22 23:00:00    0.0  130.0  ✗ 开盘为0，错误！

聚合后（修复后）:
时间                  开盘    收盘
2025-12-22 22:30:00  100.0  115.0  ✓ 正常
2025-12-22 23:00:00  115.0  130.0  ✓ 使用前一条收盘价修复
```

## 解决方案

### 核心思路

**当聚合后的开盘价为0时，使用前一条记录的收盘价代替**

这符合金融市场的常见做法：
- 开盘价通常接近前一时段的收盘价（连续交易）
- 即使有跳空，也比使用0更合理

### 实现细节

在 `service/stock_history.py` 的 `_aggregate_minute_to_30min()` 函数中添加修复逻辑：

```python
def _aggregate_minute_to_30min(df: pd.DataFrame) -> pd.DataFrame:
    """将1分钟数据聚合为30分钟数据"""

    # ... 聚合逻辑（略）...

    # 处理开盘价为0的情况：用前一条记录的收盘价代替
    # 使用 shift() 获取前一行的收盘价
    df_30min['前收盘'] = df_30min['收盘'].shift(1)

    # 记录需要修复的数量（用于日志）
    zero_open_count = (df_30min['开盘'] == 0).sum()

    # 当开盘价为0时，使用前一条的收盘价
    # 第一条记录如果开盘价为0，则使用当前的收盘价（因为没有前一条）
    df_30min['开盘'] = df_30min.apply(
        lambda row: row['前收盘'] if row['开盘'] == 0 and pd.notna(row['前收盘'])
                    else (row['收盘'] if row['开盘'] == 0 else row['开盘']),
        axis=1
    )

    # 删除临时列
    df_30min.drop(columns=['前收盘'], inplace=True)

    if zero_open_count > 0:
        logging.info(f"修复了 {zero_open_count} 条开盘价为0的记录（使用前一条收盘价）")

    return df_30min
```

### 代码说明

1. **使用 shift(1)**: 创建一个临时列 `前收盘`，包含前一行的收盘价
2. **条件判断**:
   - 如果开盘价为0且前收盘价存在 → 使用前收盘价
   - 如果开盘价为0但前收盘价不存在（第一条） → 使用当前收盘价
   - 如果开盘价不为0 → 保持原值
3. **清理临时列**: 修复完成后删除临时列
4. **日志记录**: 记录修复了多少条数据

## 测试验证

### 测试脚本

创建了 `test_aggregate_realistic.py` 进行单元测试：

```python
# 模拟真实场景：
# - 第1个30分钟: 正常数据，开盘100，收盘115
# - 第2个30分钟: 第一条开盘为0，修复后应为115
# -第3个30分钟: 第一条开盘为0，修复后应为130
```

### 测试结果

```
聚合后的30分钟数据:
0. 时间: 2025-12-22 22:30:00, 开盘:  100.00, 收盘:  115.00 ✓
1. 时间: 2025-12-22 23:00:00, 开盘:  115.00, 收盘:  130.00 ✓ 修复成功
2. 时间: 2025-12-22 23:30:00, 开盘:  130.00, 收盘:  145.00 ✓ 修复成功

验证修复逻辑:
修复后，开盘价为0的记录数: 0
✅ 成功：所有开盘价都已正确填充！

记录 0 -> 1:
  前一条收盘: 115.00
  当前条开盘: 115.00
  ✅ 当前开盘价等于前一条收盘价（修复成功）

记录 1 -> 2:
  前一条收盘: 130.00
  当前条开盘: 130.00
  ✅ 当前开盘价等于前一条收盘价（修复成功）
```

## 边界情况处理

### 1. 第一条记录的开盘价为0

**处理**: 使用当前记录的收盘价

```python
else (row['收盘'] if row['开盘'] == 0 else row['开盘'])
```

**原因**: 第一条记录没有前一条，使用收盘价是最合理的近似值

### 2. 前一条收盘价为 NaN

**处理**: 使用 `pd.notna()` 检查，如果为 NaN 则使用当前收盘价

```python
if row['开盘'] == 0 and pd.notna(row['前收盘'])
```

### 3. 所有开盘价都不为0

**处理**: 不执行任何修复，保持原值

**日志**: 不会输出"修复了X条记录"的日志

## 性能影响

### 额外开销

1. **临时列创建**: `shift(1)` 操作 - O(n)
2. **apply 遍历**: 遍历所有行 - O(n)
3. **列删除**: 删除临时列 - O(1)

### 总体影响

- 对于典型的30分钟数据（每天约13条），性能影响可以忽略
- 测试显示额外耗时 < 0.01秒

## 文件位置

- **修复代码**: `service/stock_history.py:367-386`
- **测试脚本**: `test_aggregate_realistic.py`
- **技术文档**: `docs/us_stock_30min_open_price_fix.md` (本文件)

## 相关文档

- [美股30分钟数据获取 - 技术说明](./us_stock_30min_technical_guide.md)
- [通用限流器使用指南](./rate_limiter_guide.md)

## 总结

✅ **问题**: akshare 返回的1分钟数据中开盘价为0导致聚合后的30分钟数据开盘价也为0
✅ **方案**: 使用前一条记录的收盘价代替0值的开盘价
✅ **验证**: 单元测试通过，逻辑正确
✅ **性能**: 性能影响可忽略

这个修复方案既简单又实用，符合金融数据的常识和业务逻辑。
